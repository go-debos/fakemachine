name: Build and Test

env:
  GITHUB_TAG: ghcr.io/${{ github.repository }}

on:
  push:
    branches-ignore:
      - '*.tmp'
  # Build at 04:00am every Monday
  schedule:
    - cron: "0 4 * * 1"
  pull_request:
  workflow_dispatch:

jobs:
  golangci:
    name: lint
    runs-on: ubuntu-latest
    steps:
    - uses: actions/setup-go@v6
    - uses: actions/checkout@v6
    - name: golangci-lint
      uses: golangci/golangci-lint-action@v9
      with:
        version: v2.3.0

  man-page:
    name: Check if man page has been regenerated
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v6
    - name: Check man page
      run: |
        sudo apt-get update
        sudo apt-get install -y pandoc

        # Don't check the diff of the final manpage, instead check the
        # intermediate markdown file as it is a lot less likely to
        # drastically change with different versions of pandoc etc.
        cd doc/man/ && ./create_manpage.sh
        git checkout *.1
        git diff --exit-code

  test:
    strategy:
      fail-fast: false
      matrix:
        # Currently nested virtualisation (hence kvm) is not supported on GitHub
        # actions; but the qemu backend is enough to test Fakemachine
        # functionality without hardware acceleration since the majority of code
        # is shared between the qemu and kvm backends.
        # See https://github.com/actions/runner-images/issues/183
        #
        # For Arch Linux uml is not yet supported, so only test under qemu there.
        # user-mode-linux is currently broken; see https://github.com/go-debos/fakemachine/issues/241
        os: [arch, trixie, forky]
        backend: [qemu, kvm]
    name: Test ${{matrix.os}} with ${{matrix.backend}} backend
    runs-on: 'ubuntu-latest'
    defaults:
      run:
        shell: bash
    container:
      image: ghcr.io/go-debos/test-containers/${{matrix.os}}:main
      options: >-
        --security-opt label=disable
        --cap-add=SYS_PTRACE
        --tmpfs /scratch:exec
        ${{ matrix.backend == 'kvm' && '--device /dev/kvm' || '' }}
    env:
      TMP: /scratch
    steps:
    - name: Checkout code
      uses: actions/checkout@v6
      with:
        fetch-depth: 0
        filter: tree:0

    - name: Set safe directory in container
      run: /usr/bin/git config --global --add safe.directory ${GITHUB_WORKSPACE}

    - name: Define fakemachine version
      run: echo "FAKEMACHINE_VER=$(git describe --always --tags HEAD)" >> "$GITHUB_ENV"

    - name: Test build
      run: go build -ldflags="-X main.Version=${FAKEMACHINE_VER}" ./cmd/fakemachine

    - name: Print fakemachine version
      run: ./fakemachine --version

    - name: Run unit tests (${{matrix.backend}} backend)
      run: go test -v ./... --backend=${{matrix.backend}} | tee test.out

  build-container:
    name: Build Docker container
    runs-on: ubuntu-latest
    needs:
      - golangci
      - test
    steps:
    - name: Checkout code
      uses: actions/checkout@v6
      with:
        fetch-depth: 0
        filter: tree:0

    - name: Set safe directory in container
      run: /usr/bin/git config --global --add safe.directory ${GITHUB_WORKSPACE}

    - name: Define fakemachine version
      run: echo "FAKEMACHINE_VER=$(git describe --always --tags HEAD)" >> "$GITHUB_ENV"

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Setup Docker buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.repository_owner }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract Docker metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.GITHUB_TAG }}
        tags: |
          "type=ref,event=branch"
          "type=ref,suffix=-{{sha}},event=branch"
          "type=ref,suffix=-{{date 'YYYYMMDD'}},event=branch"
          "type=ref,event=tag"
          "type=ref,event=pr"

    - name: Build & Push Docker image
      uses: docker/build-push-action@v6
      with:
        context: .
        push: true
        pull: true
        file: Dockerfile
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: FAKEMACHINE_VER=${{ env.FAKEMACHINE_VER }}

  # Job to key success status against
  allgreen:
    name: allgreen
    if: always()
    needs:
      - golangci
      - man-page
      - test
      - build-container
    runs-on: ubuntu-latest
    steps:
      - name: Decide whether the needed jobs succeeded or failed
        uses: re-actors/alls-green@release/v1
        with:
          jobs: ${{ toJSON(needs) }}

  # Keep workflow alive
  # See https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#disabling-and-enabling-workflows
  workflow-keepalive:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    needs:
      - allgreen
    permissions:
      actions: write
    steps:
      - uses: liskin/gh-workflow-keepalive@v1.2.1

  # Notify on job failure
  notify-on-failure:
    runs-on: ubuntu-latest
    needs:
      - allgreen
    if: >-
     ${{
         always() &&
         needs.allgreen.result == 'failure' &&
         github.event_name == 'schedule' &&
         github.repository == 'go-debos/fakemachine'
      }}
    steps:
      - name: Create or update failure issue
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;

            /* Reuse a single issue to avoid spam */
            const search = await github.rest.search.issuesAndPullRequests({
              q: `repo:${owner}/${repo} is:issue is:open "Scheduled CI job failed"`
            });
            const body = [
              `### Scheduled CI job failed`,
              `- Workflow: ${process.env.GITHUB_WORKFLOW}`,
              `- Run: ${context.runId}`,
              `- Commit: ${process.env.GITHUB_SHA}`,
              `- Branch/Ref: ${process.env.GITHUB_REF}`,
              `- URL: https://github.com/${owner}/${repo}/actions/runs/${context.runId}`,
              ``,
              `Please investigate and close this issue once fixed.`
            ].join("\n");

            if (search.data.items.length > 0) {
              const issue = search.data.items[0];
              await github.rest.issues.createComment({
                owner, repo, issue_number: issue.number, body
              });
            } else {
              await github.rest.issues.create({
                owner, repo,
                title: "Scheduled CI job failed",
                body,
              });
            }
